>定义一个创建对象的接口（或方法），但让子类决定实例化哪个类。工厂模式将对象的实例化延迟到子类
## 代码
```python
from abc import ABC, abstractmethod

# --- 抽象产品 (Product) ---
class Notification(ABC):
    @abstractmethod
    def send(self, message):
        pass

# --- 具体产品 (Concrete Products) ---
class EmailNotification(Notification):
    def send(self, message):
        return f"Sending Email: {message}"

class SMSNotification(Notification):
    def send(self, message):
        return f"Sending SMS: {message}"

# --- 抽象工厂 (Creator) ---
class NotifFactory(ABC):
    @abstractmethod
    def create_notification(self) -> Notification:
        """工厂方法：由子类实现，返回一个产品对象。"""
        pass

# --- 具体工厂 (Concrete Creators) ---
class EmailFactory(NotifFactory):
    def create_notification(self) -> Notification:
        return EmailNotification()

class SMSFactory(NotifFactory):
    def create_notification(self) -> Notification:
        return SMSNotification()

# --- 使用 ---
def client_code(factory: NotifFactory):
    """客户端代码只依赖于抽象工厂和产品接口。"""
    notifier = factory.create_notification()
    print(notifier.send("Hello World"))

print("--- Email 通知 ---")
client_code(EmailFactory())

print("\n--- SMS 通知 ---")
client_code(SMSFactory())
```