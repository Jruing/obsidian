---
tags:
  - Python
---
>**保证一个类在整个程序运行期间只有一个实例存在，并提供一个全局访问该实例的接口。**

## 代码

```python
class SingletonMeta(type):
    """
    单例模式的元类实现。
    """
    _instances = {}

    def __call__(cls, *args, **kwargs):
        # 检查实例字典中是否已有该类的实例
        if cls not in cls._instances:
            # 如果没有，则创建新实例
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        # 始终返回已存在的实例
        return cls._instances[cls]

class Configuration(metaclass=SingletonMeta):
    """
    配置类，保证只有一个实例。
    """
    def __init__(self, settings=None):
        # 避免重复初始化，因为 __init__ 每次调用类时都会运行
        if not hasattr(self, "_initialized"):
            self.settings = settings or {}
            self._initialized = True
            print("Configuration object initialized.")

# --- 使用 ---
# 第一次创建
config1 = Configuration({"DEBUG": True}) 
print(f"ID 1: {id(config1)}") 
# 输出: Configuration object initialized. (只打印一次)

# 第二次创建
config2 = Configuration({"LOG_LEVEL": "INFO"}) 
print(f"ID 2: {id(config2)}")

# 验证是同一个实例
print(f"config1 is config2: {config1 is config2}") # True
print(f"config1 settings: {config1.settings}") # {"DEBUG": True} (第二次的初始化参数被忽略，保持第一次的状态)
```
## 应用场景
- **配置管理：** 全局唯一的配置对象。
- **日志记录器：** 应用程序的日志记录实例。
- **数据库连接池/线程池：** 资源集中管理的对象。